
[Functional Programming in Rust - DEV Community ðŸ‘©â€ðŸ’»ðŸ‘¨â€ðŸ’» ](https://dev.to/natserract/functional-programming-in-rust-3im8)
>A Closure is a mechanism by which an inner function will have access to the variables defined in its outer functionâ€™s lexical scope even after the outer function has returned.
> an inner function that has access to retrieve a value throughout the scope both inside and outside.
>Currying is a process in functional programming in which we can transform a function with multiple arguments into a sequence of nesting functions. It returns a new function that expects the next argument inline.

>Kanishka I have been avoiding rust as too low level, but lately I have been wondering if it has a shot at becoming the first widely used backend FP ecosystem, where scala, clojure, and haskell have seemed to plateau and given up on widespread adoption.

[Introduction - Rust Design Patterns ](https://rust-unofficial.github.io/patterns/intro.html)
[Is Rust functional? ](https://www.fpcomplete.com/blog/2018/10/is-rust-functional/)
>Rust is not a functional programming language, itâ€™s imperative
>I personally donâ€™t think defining languages as â€œfunctionalâ€ makes a lot of sense, I prefer talking about specific code using a functional style
>Rust does adhere to many of the tenets of functional programming
>In many cases, you can easily, naturally, and idiomatically write Rust in a functional style

>Rust adheres to the functional principle of immutability.
>Currently, Rust provides no means of tail-call optimization (TCO). This would lead to silently broken performance expectations and potential runtime failures. I buy the argument, and look forward to something like the become keyword being added for explicit TCO.
>Rust does not adhere to the functional principle of recursion.

>Rust mostly does adhere to the functional principles of first class and higher-order functions. However, some aspects of value lifetimes and syntax add a bit more friction than a language like Haskell.
>Rust does not adhere to the functional principle of pure functions.
>Not only does Rust adhere to the functional principle of total functions, it does a better job than most other functional languages, excepting dependently typed languages.

>I believe the best way to learn to adopt these functional programming principles is to learn Haskell. As long as youâ€™re using a language where an imperative or object oriented approach feels natural, youâ€™ll tend to gravitate back to that way of thinking. Haskell kicks out the training wheels of for loops and the like.

>FP Complete provides a Haskell syllabus online for those interested in learning more.

[FP Complete Rust ](https://www.fpcomplete.com/rust/)

[Move semantics](https://www.google.com/search?qie=UTF-8)
[c++ - What is move semantics?](https://stackoverflow.com/questions/3106110/what-is-move-semantics)
[How does Rust provide move semantics?](https://stackoverflow.com/questions/29490670/how-does-rust-provide-move-semantics)
Rust London User Group (London, United Kingdom) | Meetup (chrome-extension://jaekigmcljkkalnicnjoafgfjoefkpeg/suspended.html#ttl=Rust%20London%20User%20Group%20(London%2C%20United%20Kingdom)%20%7C%20Meetup&pos=0&uri=https://www.meetup.com/Rust-London-User-Group/?utm_medium=email&utm_source=group_comms&utm_campaign=organizer-broadcast)



[Functional Programming in Rust - DEV Community 👩‍💻👨‍💻 ](https://dev.to/natserract/functional-programming-in-rust-3im8)
>A Closure is a mechanism by which an inner function will have access to the variables defined in its outer function’s lexical scope even after the outer function has returned.
> an inner function that has access to retrieve a value throughout the scope both inside and outside.
>Currying is a process in functional programming in which we can transform a function with multiple arguments into a sequence of nesting functions. It returns a new function that expects the next argument inline.

>Kanishka I have been avoiding rust as too low level, but lately I have been wondering if it has a shot at becoming the first widely used backend FP ecosystem, where scala, clojure, and haskell have seemed to plateau and given up on widespread adoption.

[Introduction - Rust Design Patterns ](https://rust-unofficial.github.io/patterns/intro.html)
[Is Rust functional? ](https://www.fpcomplete.com/blog/2018/10/is-rust-functional/)
>Rust is not a functional programming language, it’s imperative
>I personally don’t think defining languages as “functional” makes a lot of sense, I prefer talking about specific code using a functional style
>Rust does adhere to many of the tenets of functional programming
>In many cases, you can easily, naturally, and idiomatically write Rust in a functional style

>Rust adheres to the functional principle of immutability.
>Currently, Rust provides no means of tail-call optimization (TCO). This would lead to silently broken performance expectations and potential runtime failures. I buy the argument, and look forward to something like the become keyword being added for explicit TCO.
>Rust does not adhere to the functional principle of recursion.

>Rust mostly does adhere to the functional principles of first class and higher-order functions. However, some aspects of value lifetimes and syntax add a bit more friction than a language like Haskell.
>Rust does not adhere to the functional principle of pure functions.
>Not only does Rust adhere to the functional principle of total functions, it does a better job than most other functional languages, excepting dependently typed languages.

>I believe the best way to learn to adopt these functional programming principles is to learn Haskell. As long as you’re using a language where an imperative or object oriented approach feels natural, you’ll tend to gravitate back to that way of thinking. Haskell kicks out the training wheels of for loops and the like.

>FP Complete provides a Haskell syllabus online for those interested in learning more.

[FP Complete Rust ](https://www.fpcomplete.com/rust/)

[Move semantics](https://www.google.com/search?qie=UTF-8)
[c++ - What is move semantics?](https://stackoverflow.com/questions/3106110/what-is-move-semantics)
[How does Rust provide move semantics?](https://stackoverflow.com/questions/29490670/how-does-rust-provide-move-semantics)
Rust London User Group (London, United Kingdom) | Meetup (chrome-extension://jaekigmcljkkalnicnjoafgfjoefkpeg/suspended.html#ttl=Rust%20London%20User%20Group%20(London%2C%20United%20Kingdom)%20%7C%20Meetup&pos=0&uri=https://www.meetup.com/Rust-London-User-Group/?utm_medium=email&utm_source=group_comms&utm_campaign=organizer-broadcast)

